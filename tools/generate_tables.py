import numpy as np
import pandas as pd
from hopp.utilities import load_yaml
import yaml
from hopp.simulation.technologies.resource import SolarResource, WindResource
from hopp.simulation.technologies.sites import SiteInfo
import os 
# from geopy.geocoders import Nominatim
from pathlib import Path

from dotenv import load_dotenv
from hopp.utilities.keys import set_developer_nrel_gov_key, set_developer_nrel_gov_email

# Set API key
load_dotenv()
NREL_API_KEY = os.getenv("NREL_API_KEY")
NREL_API_EMAIL = os.getenv("NREL_API_EMAIL")
set_developer_nrel_gov_key(NREL_API_KEY)  # Set this key manually here if you are not setting it using the .env
set_developer_nrel_gov_email(NREL_API_EMAIL)

# Define a custom loader to ignore unknown YAML tags or objects
class CombinedLoader(yaml.SafeLoader):
    pass
def construct_python_tuple(self, node):
    return tuple(self.construct_sequence(node))
def ignore_unknown(self, node):
    return None  # Ignore and return None for any unknown object
def ignore_unknown_tags(self, tag_suffix, node):
    return None  # Ignore and return None for any unknown object

# Add the handler to the loader
CombinedLoader.add_constructor(None, ignore_unknown)

CombinedLoader.add_constructor(
    u'tag:yaml.org,2002:python/tuple',
    construct_python_tuple)

CombinedLoader.add_multi_constructor('tag:yaml.org,2002:python/object', ignore_unknown_tags)
CombinedLoader.add_multi_constructor('!python/object:', ignore_unknown_tags)
CombinedLoader.add_multi_constructor('!', ignore_unknown)
# Register a constructor to catch all python object apply tags (like NumPy)
CombinedLoader.add_multi_constructor('tag:yaml.org,2002:python/object/apply', ignore_unknown_tags)



def get_filename_from_partial_name(directory: str, search_string: str):
    """This function finds and returns the first filepath in the 
    given directory that contains the given search string. This function
    was generated by ChatGPT 20240902 and edited by Jared Thomas

    Args:
        directory (str): path to directory to search
        search_string (str): string to use to find the desired filename

    Returns:
        str: relative path to file
    """
    # List all files in the given directory
    for filename in os.listdir(directory):
        # Check if the search_string is in the filename
        if search_string in filename:
            # Construct the full path to the file
            file_path = os.path.join(directory, filename)
            # Return the path of the found file
            return file_path
    
    return False

# def get_state_from_lat_long(latitude, longitude):
#     """From ChatGPT

#     Args:
#         latitude (float): latitude in degree decimal format
#         longitude (float): longitude in degree decimal format

#     Returns:
#         str: state containing given lat lon pair
#     """
#     geolocator = Nominatim(user_agent="Jared Thomas")
#     location = geolocator.reverse((latitude, longitude), exactly_one=True)
    
#     if location and 'address' in location.raw:
#         address = location.raw['address']
#         state = address.get('state', 'State not found')
#         return state
#     else:
#         return "State not found"
    
def comparison_table(designs_to_compare=["01", "02", "03", "04", "05"]):
    ref_sys_path = "../reference-systems/"
    plant_files_path = "greenHEART/input-files/plant/"
    output_files_path = "greenHEART/output/data/"

    # get all reference design names
    reference_design_names = os.listdir(ref_sys_path)

    # define region/area
    regions = {"01": "", "02": "", "03": "Gulf Coast", "04": "", "05": ""}
    products = {"01": "Steel", "02": "Ammonia", "03": "Hydrogen", "04": "Hydrogen", "05": "Hydrogen"}
    foundation_type = {"01": "", "02": "", "03": "Fixed", "04": "Fixed", "05": "Floating"}
    storage_keys = {"lined_rock_cavern": "Rock cavern", "salt_cavern": "Salt cavern", "none": "None", "pipe": "Underground pipes", "turbine": "In-turbine", "pressure_vessel": "Pressure vessel"}
    states = {"01": "Minnesota", "02": "Texas", "03": "Texas", "04": "New York", "05": "California"}

    qoi_dictionary_list = []
    # loop over designs
    for design in designs_to_compare:
        # get full design name
        design_name = [s for s in reference_design_names if design in s][0]
        print(f"Design: {design_name}")
        # load input files
        greenheart_input = load_yaml(get_filename_from_partial_name(ref_sys_path+design_name+"/"+plant_files_path, "greenheart"))
        hopp_input = load_yaml(get_filename_from_partial_name(ref_sys_path+design_name+"/"+plant_files_path, "hopp"))
        if get_filename_from_partial_name(ref_sys_path+design_name+"/"+plant_files_path, "orbit"):
            orbit_input = load_yaml(get_filename_from_partial_name(ref_sys_path+design_name+"/"+plant_files_path, "orbit"), loader=CombinedLoader)
        else:
            orbit_input = False
        ghout_path = get_filename_from_partial_name(ref_sys_path+design_name+"/"+output_files_path, "greenheart_output")
        with open(ghout_path) as f:
            greenheart_output = yaml.full_load(f)

        # get lat lon
        lat = hopp_input["site"]["data"]["lat"]
        lon = hopp_input["site"]["data"]["lon"]

        # get QOIs
        qoi = {}
        qoi["ID"] = design
        qoi["State"] = states[design] #get_state_from_lat_long(latitude=lat, longitude=lon)
        qoi["Area"] = regions[design]
        qoi["Product"] = products[design]
        qoi["On/Offshore"] = greenheart_input["plant_design"][f"scenario{int(design)}"]["wind_location"].capitalize()
        qoi["Turbine foundation"] = foundation_type[design]
        qoi["Hydrogen storage type"] = storage_keys[greenheart_input["h2_storage"]["type"]]
        qoi["PEM electrolyzer rating (MW)"] = (greenheart_input["electrolyzer"]["rating"])
        num_turbines = hopp_input["technologies"]["wind"]["num_turbines"]
        turbine_rating_kw = hopp_input["technologies"]["wind"]["turbine_rating_kw"]
        qoi["Wind farm rating (MW)"] = num_turbines*turbine_rating_kw*1E-3
        qoi["Solar PV rating (MW)"] = hopp_input["technologies"]["pv"]["system_capacity_kw"]*1E-3
        qoi["Total generation rating (MW)"] = qoi["Wind farm rating (MW)"] + qoi["Solar PV rating (MW)"]
        qoi["Battery power rating (MW)"] = hopp_input["technologies"]["battery"]["system_capacity_kw"]*1E-3
        qoi["Battery power rating (MWh)"] = hopp_input["technologies"]["battery"]["system_capacity_kwh"]*1E-3
        # import pdb; pdb.set_trace()
        qoi["Hydrogen storage capacity (kt)"] = greenheart_output["h2_storage_capacity_kg"]*1E-6
        qoi["Hydrogen storage max fill rate (t/h)"] = greenheart_output["h2_storage_max_fill_rate_kg_hr"]*1E-3
        qoi["Number of wind turbines"] = num_turbines
        qoi["Wind turbine rating (MW)"] = turbine_rating_kw*1E-3

        solar_filename = hopp_input["site"]["solar_resource_file"].split("/")[-1]
        wind_filename = hopp_input["site"]["wind_resource_file"].split("/")[-1]

        if qoi["On/Offshore"] == "Onshore":
            qoi["Onshore latitude"] = float(lat)
            qoi["Onshore longitude"] = float(lon)
        else:
            qoi["Onshore latitude"] = float(solar_filename.split("_")[0])
            qoi["Onshore longitude"] = float(solar_filename.split("_")[1])

        # qoi["Elevation (ft)"] = hopp_input["site"]["data"]["elev"]

        if qoi["On/Offshore"] == "Offshore":
            qoi["Offshore latitude"] = float(lat)
            qoi["Offshore longitude"] = float(lon)
        # else:
        #     qoi["Offshore latitude"] = "N/A
        #     qoi["Offshore longitude"] = "N/A"

        if orbit_input:
            qoi["Distance from shore (km)"] = orbit_input["site"]["distance_to_landfall"]
            qoi["Depth (m)"] = orbit_input["site"]["depth"]
    
        resource_path = Path(ref_sys_path, design_name, "greenHEART/input-files/weather/")
        full_solar_file_path = Path(resource_path, "solar", solar_filename).absolute()
        

        full_wind_file_path = Path(resource_path, "wind", wind_filename).absolute()
        site = SiteInfo(data=hopp_input["site"]["data"], solar_resource_file=full_solar_file_path, wind_resource_file=full_wind_file_path)
        
        
        solar_resource = site.solar_resource
        qoi["Direct horizontal irradience (kWh/m$^2$)"] = np.average(solar_resource.data["df"])

        wind_resource = site.wind_resource
        wind_data = wind_resource.data["data"]
        wind_speed = [W[2] for W in wind_data]
        qoi["Average wind speed"] = np.average(wind_speed)

        if "steel_capacity" in greenheart_output.keys() and greenheart_output["steel_capacity"] is not None:
            qoi["Steel Capacity (Mt/yr)"] = greenheart_output["steel_capacity"][0]["steel_plant_capacity_mtpy"]*1E-6
        
        if "ammonia_capacity" in greenheart_output.keys() and greenheart_output["ammonia_capacity"] is not None:
            qoi["Ammonia Capacity (kt/yr)"] = greenheart_output["ammonia_capacity"][0]["ammonia_plant_capacity_kgpy"]*1E-6

        qoi["LCOH (USD/kg)"] = greenheart_output["lcoh"]

        if "steel_finance" in greenheart_output.keys() and greenheart_output["steel_finance"] is not None:
            qoi["LCOS (USD/t)"] = greenheart_output["steel_finance"][0]["sol"]["price"]
        
        if "ammonia_finance" in greenheart_output.keys() and greenheart_output["ammonia_finance"] is not None:
            qoi["LCOA (USD/kg)"] = greenheart_output["ammonia_finance"][0]["sol"]["price"]

        qoi_dictionary_list.append(qoi)
    
    # create dataframe
    qoi_df = pd.DataFrame(qoi_dictionary_list)
    qoi_df = qoi_df.set_index(keys=["ID"], drop=True)
    # qoi_df = qoi_df.set_index("ID")
    
    # Round only the numeric columns
    # qoi_df_numeric_rounded = qoi_df.select_dtypes(include=[np.number]).round(2)

    # Combine the rounded numeric columns with the non-numeric columns
    # qoi_df = pd.concat([qoi_df_numeric_rounded, qoi_df.select_dtypes(exclude=[np.number])], axis=1)

    general_format = "{:.4f}".format
    # formatters = {
    #     'Onshore latitude': lambda x: f"{x:.4f}", 
    #     'Offshore longitude': lambda x: f"{x:.4f}",   
    #     'Onshore latitude': lambda x: f"{x:.4f}",    
    #     'Offshore longitude': lambda x: f"{x:.4f}"
    # }

    # print latex table
    print(qoi_df.dtypes)
    print(qoi_df.round(2))
    print(qoi_df.fillna("N/A").T.to_latex(float_format=general_format))

    return 0

if __name__ == "__main__":

    comparison_table()